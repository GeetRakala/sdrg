//=============================================================
// Copyright 2023 Geet Rakala
// Distributed under the GNU General Public License, Version 3.
// (See accompanying file LICENSE.txt or copy at
// https://www.gnu.org/licenses/gpl-3.0.en.html)
//=============================================================

#include "graph.hpp"

int chooseRandomActiveStartNode(const BGLGraph& graph, std::mt19937& gen) {
  auto nodes_by_status = graph.getNodesByStatus();
  auto it = nodes_by_status.find(NodeStatus::Active);
  if (it == nodes_by_status.end() || it->second.empty()) {
    return -1;
  }
  const std::vector<int>& activeNodeIndices = it->second;
  std::uniform_int_distribution<> distrib(0, activeNodeIndices.size() - 1);
  int randomNodeIndex = activeNodeIndices[distrib(gen)];
  return randomNodeIndex;
}

std::vector<int> constructPath(int target, const std::vector<int>& predecessors) {
  std::vector<int> path;
  for (int at = target; at != -1; at = predecessors[at]) {
    path.push_back(at);
  }
  std::reverse(path.begin(), path.end());
  return path;
}

class CustomDijkstraVisitor {
  public:
    CustomDijkstraVisitor(int end, bool findToEndNode, const std::vector<int>& predecessors)
      : endNode(end), findToEndNode(findToEndNode), predecessors(predecessors) {}

    template <typename Vertex, typename Graph>
      void examine_vertex(Vertex u, Graph& g) const {
        if (g[u].status == NodeStatus::Active &&
            (!findToEndNode || u == endNode) &&
            u != predecessors[0]) {
          throw u;  // Use exception to signal found node.
        }
      }

    template <typename Vertex, typename Graph>
      void discover_vertex(Vertex u, const Graph& g) const {
        // Intentionally left empty for now
      }

    template <typename Edge, typename Graph>
      void examine_edge(Edge e, const Graph& g) const {
        // Intentionally left empty for now
      }

    template <typename Edge, typename Graph>
      void edge_relaxed(Edge e, const Graph& g) const {
        // Intentionally left empty for now
      }

    template <typename Edge, typename Graph>
      void edge_not_relaxed(Edge e, const Graph& g) const {
        // Intentionally left empty for now
      }

    template <typename Vertex, typename Graph>
      void initialize_vertex(Vertex u, const Graph& g) const {
        // Intentionally left empty for now
      }

    template <typename Vertex, typename Graph>
      void finish_vertex(Vertex u, const Graph& g) const {
        // Intentionally left empty for now
      }

  private:
    int endNode;
    bool findToEndNode;
    const std::vector<int>& predecessors;
};


std::tuple<int, double, std::vector<int>> ActivatedDijkstra(
    const BGLGraph& bglGraph,
    int start,
    int end,
    bool findToEndNode,
    bool debugDijkstra
    ) {
  const Graph& graph = bglGraph.getGraph();
  std::vector<double> distances(num_vertices(graph), std::numeric_limits<double>::infinity());
  std::vector<int> predecessors(num_vertices(graph), -1);


  int foundNode = -1;

  try {
    CustomDijkstraVisitor customVisitor(end, findToEndNode, predecessors);
    dijkstra_shortest_paths(graph, start,
        boost::visitor(customVisitor)
        .distance_map(boost::make_iterator_property_map(distances.begin(), get(boost::vertex_index, graph)))
        .predecessor_map(boost::make_iterator_property_map(predecessors.begin(), get(boost::vertex_index, graph)))
        );
  } catch (unsigned long node) {
    foundNode = static_cast<int>(node);
  }

  if (foundNode != -1) {
    std::vector<int> path;
    for (int at = foundNode; at != -1; at = predecessors[at]) {
      path.push_back(at);
    }
    std::reverse(path.begin(), path.end());
    return {foundNode, distances[foundNode], path};
  }

  return {-1, std::numeric_limits<double>::infinity(), {}};
}



/**
 * @brief Finds the local minimum based on distance and range between active nodes.
 *
 * @param bglGraph The BGL graph containing nodes and edges.
 * @param gen Random number generator.
 * @return A tuple containing the node index, range or distance, path if applicable, and a boolean flag indicating if the value is a range.
 */
std::tuple<int, double, std::vector<int>, bool> findLocalMinimum(const BGLGraph& bglGraph, std::mt19937& gen, bool debug, bool debugDijkstra) {

  const Graph& graph = bglGraph.getGraph(); // Extracting Graph from BGLGraph

  int startNode = chooseRandomActiveStartNode(bglGraph, gen);
  if (debug) std::cout << "Start Node: " << startNode << " with range: " << graph[startNode].range << "\n";

  auto result1 = ActivatedDijkstra(bglGraph, startNode, -1, false, debugDijkstra);

  int nextNode = std::get<0>(result1);

  double distanceToNextNode = std::get<1>(result1);

  if (debug) std::cout << "Next Node: " << nextNode << " with range: " << graph[nextNode].range << "\n";
  if (debug) std::cout << "Distance to next node: " << distanceToNextNode << "\n";

  double localMin = std::min({graph[startNode].range, distanceToNextNode});

  if (debug) std::cout << "Minimum between start node and distance to next node: " << localMin << "\n";

  if (localMin == graph[startNode].range) {
    if (debug) std::cout << "Done finding Local minimum\n ---EXIT 1--- \n";
    return {startNode, graph[startNode].range, {}, true};
  }

  while (true) {

    auto result2 = ActivatedDijkstra(bglGraph, nextNode, -1, false, debugDijkstra);

    int nextToNextNode = std::get<0>(result2);

    double distanceToNextToNextNode = std::get<1>(result2);

    if (debug) std::cout << "Next to Next Node: " << nextToNextNode << " with range: " << graph[nextToNextNode].range << "\n";
    if (debug) std::cout << "Distance to next to next node: " << distanceToNextToNextNode << "\n";

    localMin = std::min({graph[nextNode].range, distanceToNextNode, graph[nextToNextNode].range, distanceToNextToNextNode});

    if (debug) std::cout << "Minimum between next node, distance to next node, next to next node, distance to next to next node: " << localMin << "\n";

    if (localMin == graph[nextNode].range) {
      if (debug) std::cout << "Done finding Local minimum\n ---EXIT 2--- \n";
      return {nextNode, graph[nextNode].range, {}, true};
    }

    else if (localMin == distanceToNextNode) {
      if (debug) std::cout << "Done finding Local minimum\n ---EXIT 3--- \n";
      return {nextNode, distanceToNextNode, std::get<2>(result1), false};
    }

    //else if (localMin == graph[nextToNextNode].range) {
    //  if (debug) std::cout << "Done finding Local minimum\n ---EXIT 4--- \n";
    //  return {nextToNextNode, graph[nextToNextNode].range, {}, true};
    //}

    //else if (localMin == distanceToNextToNextNode) {
    else {
      nextNode = nextToNextNode;
      distanceToNextNode = distanceToNextToNextNode;
      std::get<2>(result1) = std::get<2>(result2);

      if (debug) std::cout << "One loop in while without EXIT \n";
      if (debug) std::cout << "Next Node: " << nextNode << " with range: " << graph[nextNode].range << "\n";
      if (debug) std::cout << "Distance to next node: " << distanceToNextNode << "\n";
    }
  }
  }
